import ColumnDefinition from 'lib/schema/ColumnDefinition.js';
import ElegantTable from "./ElegantTable.js";
import {
  BooleanColumnDefinition, ConstraintColumnDefinition,
  GeneralColumnDefinition,
  NumberColumnDefinition,
} from './ColumnDefinitions.js';
import ElegantFunction from './ElegantFunction.js';

export default class PostgresTable extends ElegantTable {

  protected enclosure: string = '"';

  boolean(columnName: string, defaultValue?: boolean, nullable?: boolean): ColumnDefinition {
    const column = new BooleanColumnDefinition(columnName, defaultValue, nullable)
    this.columns.push(column)
    return column
  }

  json(columnName: string, defaultValue?: any, nullable?: boolean): ColumnDefinition {
    const column = new GeneralColumnDefinition(columnName, 'JSONB')
    column.default(defaultValue)
    if (nullable !== undefined) {
      if (nullable) {
        column.null()
      } else {
        column.notNull()
      }
    }
    this.columns.push(column)
    return column
  }

  fn(name:string, fn:(fn:ElegantFunction) => void) {
    let elegantFunction = new ElegantFunction(name)
    if (typeof fn === 'function') fn(elegantFunction)
    const sql = this.functionToStatement(elegantFunction)
    const connection = this.constructor.name.toLowerCase().replace('table', '')
    if (this.statements.has(connection)) {
      this.statements.get(connection).push(sql)
    } else {
      this.statements.set(connection, [sql])
    }
  }

  functionToStatement(fn: ElegantFunction): string {
    if (this.action === 'drop') {
      // DROP FUNCTION
      let sql = `DROP FUNCTION "${fn.name}"`
      const typeSql = (fn.params as any).columns
        .map(column => column.type)
        .join(', ')
      sql += typeSql ? `(${typeSql})` : '()'
      return sql
    } else if (this.action === 'alter') {
      // UPDATE FUNCTION
    } else if (this.action === 'create') {
      // CREATE FUNCTION
      let sql = `CREATE FUNCTION "${fn.name}"`
      let inputSql = fn.params.getColumns()
        .map(column => {
          return `${column.name} ${column.type}`
        })
        .join(', ')
      sql += inputSql ? `(${inputSql})\n` : '()\n'
      sql += `RETURNS ${fn.returns.$.returns.type} AS $$\n`
      sql += `DECLARE\n  ${fn.returns.$.returns.name} ${fn.returns.$.returns.type};\n`
      sql += `BEGIN\n`
      sql += `${fn.getBody()}\n`

      sql+= `END;\n$$ LANGUAGE plpgsql`
      return sql
    }
  }

  protected columnsToSql() {
    let sql = '  ' + this.columns
      .filter(column => !(column instanceof ConstraintColumnDefinition))
      .map(column => {
        return this.columnToSql(column)
      }).join(',\n  ')
    if (this.hasMultiplePrimaryKeys()) {
      sql += `,\nPRIMARY KEY("${this.getPrimaryKeyColumns().map(c => c.name).join('", "')}")`
    }
    return sql;
  }

  protected columnToSql(column: ColumnDefinition): string {
    if (column instanceof ConstraintColumnDefinition) return
    let type = column.type.toUpperCase();
    if (column instanceof NumberColumnDefinition) {
      if (column.type.includes('INT'))
        [type] = column.type.split('(')
    }
    let sql = `${this.enclose(column.name)} ${type}`;
    if (column.$.nullable !== undefined) sql += column.$.nullable ? ' NULL' : ' NOT NULL'
    if (column.$.autoIncrement) sql += ' GENERATED BY DEFAULT AS IDENTITY'
    if (column.$.primary && !this.hasMultiplePrimaryKeys()) {
      sql += ' PRIMARY KEY'
    } else if (column.$.unique) {
      sql += (column.$.key) ? ' UNIQUE KEY' : ' UNIQUE'
    }
    if (column.$.default) sql += ` DEFAULT ${column.$.default}`
    if (column.$.key) sql += ` KEY ${column.$.key}`
    if (column.$.comment) sql += ` COMMENT '${column.$.comment}'`
    return sql
  }

  protected getDatabaseColumns(): Promise<any[]> {
    let query = `
      SELECT distinct c.column_name, c.data_type, c.udt_name, t.constraint_type, c.character_maximum_length, c.is_nullable, c.column_default,
         c.numeric_precision, c.numeric_scale, c.is_identity, c.identity_generation
      FROM information_schema.columns c
          left join information_schema.key_column_usage k on c.column_name = k.column_name
          left join information_schema.table_constraints t on t.constraint_name = k.constraint_name
      WHERE c.table_name = $1
    `

    return this.db.query( query, [this.tableName])
      .then(fields => fields.map((field:any) => {
        let {column_name: name, udt_name: type, data_type, character_maximum_length: length} = field

        switch(type) {
          case 'int4': type = 'int'; break;
          case 'int8': type = 'bigint'; break;
          case 'int2': type = 'smallint'; break;
          case 'numeric': type = 'numeric'; break;
          case 'varchar': type = `varchar(${length})`; break;
          case 'bpchar': type = `char(${length})`; break;
          case 'text': type = 'text'; break;
          case 'bool': type = 'boolean'; break;
          case 'date': type = 'date'; break;
          case 'timestamp': type = 'timestamp'; break;
          case 'timestamptz': type = 'timestamptz'; break;
          case 'bytea': type = 'bytea'; break;
          case 'jsonb': type = 'jsonb'; break;
        }

        const column = new GeneralColumnDefinition(name, type, Number(length)||undefined)
        if (field.is_nullable === 'YES') column.null()
        if (field.is_identity === 'YES') column.autoIncrement()
        if (field.constraint_type == 'PRIMARY KEY') column.primary()
        if (field.constraint_type == 'UNIQUE') column.unique()
        return column
      }))
  }
}
