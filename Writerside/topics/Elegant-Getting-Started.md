# Elegant ORM: Getting Started
<show-structure depth="2"/>
## Introduction

The Elegant ORM (Object-Relational Mapper) transforms database tables into intuitive TypeScript classes, letting you work with database records as objects rather than writing raw SQL. This object-oriented approach makes your code more maintainable, readable, and enjoyable to write.

With Elegant ORM, each database table is represented by a Model class. These models provide methods to query, insert, update, and delete records while maintaining type safety and providing a clean, expressive API.

## Why Use an ORM?

**Type Safety** - Define your data structures once, and TypeScript ensures you're always working with the correct types.

**Productivity** - Write less code. Instead of crafting SQL for every operation, use intuitive methods that handle the heavy lifting.

**Maintainability** - Business logic stays in your application code, not scattered across SQL strings throughout your codebase.

**Flexibility** - When you need raw SQL power, it's always available. Elegant ORM complements rather than replaces SQL.

## Generating Model Classes
To get started, let's create an Elegant model. Models typically live in the `resources/database/models` directory and extend the `Model` class. You may use the `make:model` Elegant command to generate a new model:

```bash
elegant make:model User
```
Generate corresponding type definitions for models based on database schema
```bash
elegant make:types
```
### Inspecting Models
Sometimes it can be difficult to determine all of a model's available attributes and relationships just by skimming its code. Instead, try the `model:show` Elegant command, which provides a convenient overview of all the model's attributes and relations:

```bash
elegant model:show
```

## Elegant Model Conventions
Models generated by the `elegant make:model` command will be placed in the `resources/database/models` directory. Let's examine a basic model class and discuss some of Elegant's key conventions:

```typescript
import { Model } from '@pristine/elegant'

class User extends Model {}
```

### Table Names
After glancing at the example above, you may have noticed that we did not tell Elegant which database table corresponds to our User model. By convention, the "snake case", plural name of the class will be used as the table name unless another name is explicitly specified. So, in this case, Elegant will assume the User model stores records in the users table, while an `SocialMediaLinks` model would store records in an `social_media_links` table.

If your model's corresponding database table does not fit this convention, you may manually specify the model's table name by defining a table property on the model:

```typescript
import { Model } from '@pristine/elegant'

class User extends Model {
  protected table = 'super_users'
}
```

### Primary Keys
Elegant will also assume that each model's corresponding database table has a primary key column named id. If necessary, you may define a protected `primaryKey` property on your model to specify a different column that serves as your model's primary key:

```typescript
import { Model } from '@pristine/elegant'

class User extends Model {
  protected primaryKey = 'user_id'
}
```

### Timestamps
By default, Elegant expects `created_at` and `updated_at` columns to exist on your model's corresponding database table. Elegant will automatically set these column's values when models are created or updated. If you do not want these columns to be automatically managed by Elegant, you should define a `timestamps` property on your model with a value of false:

```typescript
import { Model } from '@pristine/elegant'

class User extends Model {
  protected timestamps = false
}
```

If you need to customize the names of the columns used to store the timestamps, you may define `created_at` and `updated_at` protected properties on your model:

```typescript
import { Model } from '@pristine/elegant'

class User extends Model {
  protected created_at = 'creation_date'
  protected updated_at = 'last_updated'
}
```

### Database Connections
By default, all Elegant models will use the default database connection configured for your application. If you would like to specify a different connection that should be used when interacting with a particular model, you should define a $connection property on the model:

```typescript
import { Model } from '@pristine/elegant'

class User extends Model {
  protected connection = 'postgres'
}
```

### Default Attribute Values
By default, a newly instantiated model instance will not contain any attribute values. If you would like to define the default values for some of your model's attributes, you may define an `attributes` property on your model. Attribute values placed in the `attributes` array should be in their raw, "storable" format as if they were just read from the database:

```typescript
import { Model } from '@pristine/elegant'

class User extends Model {
  protected attributes = {
    phone: '555-555-5555',
    isActive: true
  }
}
```

### Configuring Strictness
Laravel offers several methods that allow you to configure Elegant's behavior and "strictness" in a variety of situations.

First, the `lazyLoading` configuration option indicates if lazy loading should be enabled. For example, you may wish to only disable lazy loading in non-production environments so that your production environment will continue to function normally even if a lazy loaded relationship is accidentally present in production code. Typically, this option can be configured in `elegant.config.js`.

Also, you may instruct Elegant to throw an exception when attempting to fill an unfillable attribute by configuring `strictAttributes`. This can help prevent unexpected errors during local development when attempting to set an attribute that has not been added to the model's fillable array:

```javascript 
export default {
  default: 'mysql',
  connections: {/** connection configurations **/},
  models: {
    lazyLoading: false,
    strictAttributes: true,
    directory: 'resources/database/models'
  }
}
```

## Retrieving Models
Once you have created a model and [its associated database table](Migrations.md#generating-migrations), you are ready to start retrieving data from your database. You can think of each Elegant model as a powerful [query builder](Query-Builder.md) allowing you to fluently query the database table associated with the model. The model's `all` method will retrieve all of the records from the model's associated database table:

```typescript
// user.model.ts
import { Model } from '@pristine/elegant'

class UserModel extends Model {}

export default new UserModel()
```
```typescript
// user.service.ts
import User from './user.model'

const users = await User.all()
```

#### Building Queries
The Elegant `all` method will return all the results in the model's table. However, since each Elegant model serves as a [query builder](Query-Builder.md), you may add additional constraints to queries and then invoke the `get` method to retrieve the results:

```typescript
Users
  .where('active', 1)
  .orderBy('name')
  .take(10)
  .get()
```

>Since Elegant models are query builders, you should review all of the methods provided by Laravel's query builder. You may use any of these methods when writing your Elegant queries.

#### Refreshing Models
If you already have an instance of an Elegant model that was retrieved from the database, you can "refresh" the model using the fresh and refresh methods. The fresh method will re-retrieve the model from the database. The existing model instance will not be affected:

```typescript
User.where('name','jack').first()
User.refresh()
```
The refresh method will re-hydrate the existing model using fresh data from the database. In addition, all of its loaded relationships will be refreshed as well:

```typescript
User.where('name','jack').first()
User.name = 'john'
User.refresh()
User.name // "john"
```


### Model Conventions

Elegant follows sensible conventions to minimize configuration:

- **Table Names** - By default, the model class name is converted to snake_case and pluralized (e.g., `UserProfile` â†’ `user_profiles`)
- **Primary Keys** - Assumes an auto-incrementing column named `id`
- **Timestamps** - Automatically manages `created_at` and `updated_at` columns

You can override these conventions as needed:

```typescript 
export class Account extends Model {
  protected table = 'account_records'; // Custom table name protected
  primaryKey = 'account_id'; // Custom primary key
  public timestamps = false; // Disable timestamp management
}
```

### Finding by Primary Key

```typescript 
// Find user with ID 1 
const user = await User.find(1);
if (user) { console.log(user.email); }
```

```typescript
// Find or throw an error if not found 
const user = await User.findOrFail(1);
```

### Adding Constraints

```typescript 
// Find all active 
users const activeUsers = await User.where('active', true).get();
```

```typescript
// Find users with complex conditions 
const vipUsers = await User
  .where('subscription_type', 'premium') 
  .where('status', 'active') 
  .orderBy('created_at', 'desc') 
  .limit(10) 
  .get();
```


## Creating and Updating Models

### Creating New Records

There are several ways to create new model instances:
#### Method 1: Create and save
```typescript 

const user = new User(); 
user.name = 'Jane Doe'; 
user.email = 'jane@example.com'; 
await user.save();
```
#### Method 2: Create with attributes
```typescript
const user = await User.create({ 
  name: 'John Smith', 
  email: 'john@example.com' 
});
```
#### Method 3: Mass assignment
```typescript
const users = await User.createMany([ 
  { name: 'Alice', email: 'alice@example.com' }, 
  { name: 'Bob', email: 'bob@example.com' } 
]);

```

### Updating Records

#### Update a single model
```typescript 
const user = await User.find(1); 
user.name = 'Updated Name'; 
await user.save();
```

#### Update using query
```typescript
await User 
  .where('status', 'inactive') 
  .update({ status: 'archived' });
```

#### Update or create
```typescript
const user = await User.updateOrCreate( 
  { email: 'user@example.com' }, 
  // Search criteria 
  { name: 'User Name', active: true } 
  // Values to update/create 
);
```


## Deleting Models

### Delete Single Records

#### Delete after retrieving
```typescript 
const user = await User.find(1); 
await user.delete();
```

#### Delete by primary key
```typescript
await User.destroy(1);
```

#### Delete multiple by IDs
```typescript
await User.destroy([1, 2, 3]);
```

### Delete with Constraints

#### Delete all inactive
```typescript 
users await User.where('active', false).delete();
```

#### Delete with conditions
```typescript
await User 
  .where('created_at', '<', oldDate) 
  .where('verified', false) 
  .delete();
```

## Relationships

Define relationships between models to work with related data:

```typescript 
export class User extends Model { 
  // One-to-many relationship 
  posts() { 
    return this.hasMany(Post, 'user_id'); 
  }
  // One-to-one relationship 
  profile() { 
    return this.hasOne(Profile, 'user_id'); 
  }
  // Many-to-many relationship
  roles() { 
    return this.belongsToMany(Role, 'user_roles'); 
  }
}
// Access relationships 
const user = await User.find(1);
const posts = await user.posts().get(); 
const profile = await user.profile().first();
```

## Working with Timestamps

Elegant automatically manages `created_at` and `updated_at` timestamps:

```typescript
const user = await User.create({
  name: 'Jane Doe',
  email: 'jane@example.com'
});

console.log(user.created_at); // Current timestamp
console.log(user.updated_at); // Current timestamp

// Update the model
user.name = 'Jane Smith';
await user.save();

console.log(user.updated_at); // Updated to current timestamp
```

Disable timestamps if your table doesn't use them:

```typescript
export class Log extends Model {
  protected table = 'logs';
  public timestamps = false;
}
```

### Advanced Features
#### Using Different Conections
Specify which database connection a model should use:
```typescript
export class AnalyticsEvent extends Model {
  protected connection = 'analytics';
  protected table = 'events';
}
```

### Custom Queries
Drop down to raw SQL when needed:

```typescript
const users = await User.raw(
  'SELECT * FROM users WHERE created_at > ?',
  [lastWeek]
);
```

### Eager Loading
Optimize queries by loading relationships upfront:

```typescript
// N+1 problem - makes many queries
const users = await User.all();
for (const user of users) {
  const posts = await user.posts().get(); // Query per user
}

// Eager loading - single query
const users = await User.with('posts').get();
for (const user of users) {
  console.log(user.posts); // Already loaded
}
```

## Best Practices
1. **Use Type Definitions** - Define all model properties with TypeScript types for better IDE support
3. **Eager Load Relationships** - Avoid N+1 query problems by using eager loading
4. **Validate Data** - Implement validation in your models before saving
5. **Use Transactions** - Wrap related operations in transactions to maintain data integrity

## Next Steps
- Explore the [Query Builder](Query-Builder.md) for more complex queries
- Learn about [Migrations](Migrations.md) to manage your database schema
- Review [database configuration](Getting-Started.md) options
